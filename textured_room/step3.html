<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Textured Room – Step 2 (OrbitControls)</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
        }

        .hint {
            position: absolute;
            top: 10px;
            left: 50%;
            transform:
                translateX(-50%);
            color: #ddd;
            font-family: system-ui, sans-serif;
            font-size:
                14px;
            text-align: center;
            background: rgba(0, 0, 0, 0.35);
            padding: 6px 10px;
            border-radius:
                8px;
            user-select: none;
        }
    </style>
</head>

<body>
    <div class="hint">Drag = rotate · Scroll = zoom · Right-drag = pan · R = reset camera</div>
    <!-- Three.js non-module (kompatibel OrbitControls global) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <!-- OrbitControls non-module untuk v0.146.0 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // === 1) Scene ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // === 2) Camera ===
        const camera = new THREE.PerspectiveCamera(
            60, window.innerWidth / window.innerHeight, 0.1, 100
        );

        const defaultPos = new THREE.Vector3(0, 1.5, 3); // posisi default untuk reset
        camera.position.copy(defaultPos);
        camera.lookAt(0, 1, 0); // fokus ke tengah ruang (tinggi 1 m)

        // ========= 3) Lights =========
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        const point = new THREE.PointLight(0xffffff, 1.0, 100);
        point.position.set(0, 2.4, 0); // lampu dekat atap, pusat ruangan
        scene.add(ambient, point);

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.y = 1;
        scene.add(cube);

        // ========= 4) Texture loader + fallback =========
        const loader = new THREE.TextureLoader();
        function makeFallback(label) {
            const c = document.createElement('canvas');
            c.width = c.height = 256;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#999'; ctx.font = '16px system-ui';
            ctx.fillText(label, 20, 130);
            return new THREE.CanvasTexture(c);
        }

        function safeLoad(path, label) {
            let tex = loader.load(
                path,
                () => { tex.needsUpdate = true; },
                undefined,
                () => { tex = makeFallback(label); }
            );
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.minFilter = THREE.LinearMipmapLinearFilter;
            tex.magFilter = THREE.LinearFilter;
            // tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return tex;
        }

        // Ganti dengan file Anda (opsional); jika tidak ada, fallback akan tampil
        const floorTex = safeLoad('./floor.jpg', 'floor.jpg?');
        const wallTex = safeLoad('./wall.jpg', 'wall.jpg?');
        const ceilingTex = safeLoad('./ceiling.jpg', 'ceiling.jpg?');

        // Tiling bawaan
        floorTex.repeat.set(2, 2);
        wallTex.repeat.set(1.5, 1);
        ceilingTex.repeat.set(1, 1);

        // ========= 5) Materials – FrontSide (menghadap interior) =========
        const matFloor = new THREE.MeshStandardMaterial({
            map: floorTex,
            side: THREE.DoubleSide
        });
        const matWall = new THREE.MeshStandardMaterial({
            map: wallTex,
            side: THREE.DoubleSide
        });
        const matCeiling = new THREE.MeshStandardMaterial({
            map: ceilingTex,
            side: THREE.DoubleSide
        });

        // ========= 6) Room Geometry (dilihat dari dalam) =========
        // Ukuran ruangan
        const W = 4; // lebar X
        const H = 3; // tinggi Y
        const D = 6; // panjang Z

        // LANTAI: normal +Y (rotasi -90° X)
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matFloor);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, 0);
        scene.add(floor);

        // ATAP: normal -Y (rotasi +90° X)
        const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(W, D),
            matCeiling);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(0, H, 0);
        scene.add(ceiling);

        // DINDING BELAKANG (z = -D/2): sisi interior menghadap +Z → TANPA rotasi
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H),
            matWall);
        backWall.position.set(0, H / 2, -D / 2);
        scene.add(backWall);

        // DINDING DEPAN (z = +D/2): sisi interior menghadap -Z → rotasi 180°Y
        const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H),
            matWall);
        frontWall.rotation.y = Math.PI;
        frontWall.position.set(0, H / 2, D / 2);
        scene.add(frontWall);

        // DINDING KIRI (x = -W/2): sisi interior menghadap +X → rotasi -90°Y
        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H),
            matWall);
        leftWall.rotation.y = -Math.PI / 2;
        leftWall.position.set(-W / 2, H / 2, 0);
        scene.add(leftWall);

        // DINDING KANAN (x = +W/2): sisi interior menghadap -X → rotasi +90°Y
        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H),
            matWall);
        rightWall.rotation.y = Math.PI / 2;
        rightWall.position.set(W / 2, H / 2, 0);
        scene.add(rightWall);

        // ========= 7) Renderer =========
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
        floorTex.anisotropy = maxAnisotropy;
        wallTex.anisotropy = maxAnisotropy;
        ceilingTex.anisotropy = maxAnisotropy;

        // ========= 8) OrbitControls =========
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1, 0); // fokus ke tengah ruang

        // ========= 9) Window Resize Handler =========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========= 10) Reset Camera (tombol R) =========
        window.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                camera.position.copy(defaultPos);
                controls.target.set(0, 1, 0);
                controls.update();
            }
        });

        // ========= 11) Animation Loop =========
        function animate() {
            requestAnimationFrame(animate);

            // Rotate the cube
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;

            controls.update(); // untuk damping
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>