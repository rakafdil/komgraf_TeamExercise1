<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Textured Room – Inside Only (Final Fixed)</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #111;
    }
    canvas { display: block; }
    .hint {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #ddd;
      font-family: system-ui, sans-serif;
      font-size: 14px;
      text-align: center;
      background: rgba(0,0,0,0.35);
      padding: 6px 10px;
      border-radius: 8px;
      user-select: none;
    }
  </style>
</head>

<body>
  <div class="hint">Drag = rotate · Scroll = zoom · Right-drag = pan · R = reset camera</div>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // === 1) Scene ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    // === 2) Camera ===
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    const defaultPos = new THREE.Vector3(0, 1.5, 3);
    camera.position.copy(defaultPos);
    camera.lookAt(0, 1, 0);

    // === 3) Renderer ===
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // === 4) Controls ===
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 1, 0);
    controls.minDistance = 0.5;
    controls.maxDistance = 12;

    // === 5) Lights ===
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    const point = new THREE.PointLight(0xffffff, 1.2, 100);
    point.position.set(0, 2.4, 0);
    scene.add(ambient, point);

    // === 6) Texture Loader ===
    const loader = new THREE.TextureLoader();
    const floorTex   = loader.load('floor.jpg');
    const wallTex    = loader.load('wall.jpg');
    const ceilingTex = loader.load('ceiling.jpg');

    floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
    wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
    ceilingTex.wrapS = ceilingTex.wrapT = THREE.RepeatWrapping;
    floorTex.repeat.set(2, 2);
    wallTex.repeat.set(1.5, 1);
    ceilingTex.repeat.set(1, 1);

    // === 7) Materials (semua hanya tampak dari dalam) ===
    const matFloor   = new THREE.MeshStandardMaterial({ map: floorTex, side: THREE.FrontSide });
    const matWall    = new THREE.MeshStandardMaterial({ map: wallTex, side: THREE.FrontSide });
    const matCeiling = new THREE.MeshStandardMaterial({ map: ceilingTex, side: THREE.FrontSide });

    // === 8) Ukuran Ruangan ===
    const W = 4, H = 3, D = 6;

    // === 9) Membuat Ruangan dengan orientasi dibalik ke dalam ===

    // Lantai
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matFloor);
    floor.rotation.x = -Math.PI / 2;
    floor.scale.x = -1; // arah normal ke dalam
    scene.add(floor);

    // Atap
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matCeiling);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = H;
    ceiling.scale.x = -1;
    scene.add(ceiling);

    // Dinding belakang
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
    backWall.position.set(0, H / 2, -D / 2);
    backWall.scale.x = -1;
    scene.add(backWall);

    // Dinding depan
    const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
    frontWall.rotation.y = Math.PI;
    frontWall.position.set(0, H / 2, D / 2);
    frontWall.scale.x = -1;
    scene.add(frontWall);

    // Dinding kiri
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.set(-W / 2, H / 2, 0);
    leftWall.scale.x = -1;
    scene.add(leftWall);

    // Dinding kanan
    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.set(W / 2, H / 2, 0);
    rightWall.scale.x = -1;
    scene.add(rightWall);

    // === 10) Render Loop ===
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // === 11) Resize & Reset ===
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        camera.position.copy(defaultPos);
        controls.target.set(0, 1, 0);
        controls.update();
      }
    });
  </script>
</body>
</html>
